{"remainingRequest":"/Users/ziyiwang/Desktop/COMP435-final-proj/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ziyiwang/Desktop/COMP435-final-proj/src/views/solarSystem.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/ziyiwang/Desktop/COMP435-final-proj/src/views/solarSystem.vue","mtime":1702875013472},{"path":"/Users/ziyiwang/Desktop/COMP435-final-proj/node_modules/cache-loader/dist/cjs.js","mtime":1702276330406},{"path":"/Users/ziyiwang/Desktop/COMP435-final-proj/node_modules/babel-loader/lib/index.js","mtime":1702276326097},{"path":"/Users/ziyiwang/Desktop/COMP435-final-proj/node_modules/cache-loader/dist/cjs.js","mtime":1702276330406},{"path":"/Users/ziyiwang/Desktop/COMP435-final-proj/node_modules/vue-loader/lib/index.js","mtime":1702276330641}],"contextDependencies":[],"result":["\nimport * as THREE from \"three\";\nimport TWEEN from \"@tweenjs/tween.js\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\"; \nimport SetSolarSystem from \"./components/SetSolarSystem\";\nimport PlanetText from \"./components/PlanetText\";\nimport planetData from \"./planetData.js\";\nimport universeImg from \"./img/universe.jpg\"; \nimport starImg from \"./img/star.jpg\";\nimport venusAtmosphereImg from \"./img/venusAtmosphere.jpg\";\nimport moonImg from \"./img/moon.jpg\";\nimport earthNormalImg from \"./img/earthNormal.jpg\";\nimport earthCloudsImg from \"./img/earthClouds.jpg\";\n\nlet scene = null; //the scene\nlet camera = null; //the camera\nlet orbitControls = null; //mouse control\nexport default {\n  props: {},\n  components: { SetSolarSystem, PlanetText },\n  data() {\n    return {\n      dom: \"\", \n      renderer: \"\",\n      anId: null,\n      planetList: planetData,\n      isRevolution: true, //revolution status\n      isRotation: true, //rotation status\n      raycaster: new THREE.Raycaster(), //to get the coordinates of mouse when on click\n      mouse: new THREE.Vector2(), \n      clickPlanet: \"\", //the on click planet\n    };\n  },\n  computed: {},\n  watch: {},\n  created() {},\n  mounted() {\n    this.init();\n  },\n  methods: {\n    //change the two settings (rotation and revolution)\n    changeSet(data) {\n      if (data.key == \"isRevolution\") {\n        this.isRevolution = data.val;\n      }\n      if (data.key == \"isRotation\") {\n        this.isRotation = data.val;\n      }\n    },\n    //destroy the scene\n    destroyScene() {\n      cancelAnimationFrame(this.anId); //stop rendering according to anId\n      this.renderer.forceContextLoss();\n      this.renderer.dispose();\n      scene.clear();\n      scene = null;\n      camera = null;\n      orbitControls = null;\n      this.dom.innerHTML = null;\n      this.renderer = null;\n    },\n\n    //initialize the scene\n    init() {\n      this.dom = document.getElementById(\"planetDiv\"); //get dom\n      let width = this.dom.clientWidth;\n      let height = this.dom.clientHeight;\n      scene = new THREE.Scene();\n      camera = new THREE.PerspectiveCamera(45, width / height, 1, 50000); //create the perspective camera\n      camera.position.set(0, 500, 2700); //set camera position\n      camera.lookAt(0, 0, 0);\n      //create renderer\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true, //antialiasing\n        alpha: true, //transparency\n      });\n      this.renderer.setClearColor(0x000000, 0.1); //set scene transparency\n      this.renderer.setSize(width, height); //set renderer size\n      this.dom.appendChild(this.renderer.domElement); //add renderer to dom to form canvas\n      this.createUniverse(); //create universe\n      this.createStars(); //create stars\n      this.createLight(); //create light\n      //traverse planet data to generate planets and their orbital paths\n      this.planetList.forEach((e) => {\n        this.createSphere(e);\n        this.createTrack(e);\n      });\n      this.createOrbitControls(); //create mouse controls\n      this.render(); //render\n    },\n\n    //create universe\n    createUniverse() {\n      let universeGeometry = new THREE.SphereGeometry(7000, 100, 100);\n      let universeMaterial = new THREE.MeshLambertMaterial({\n        //texure\n        map: new THREE.TextureLoader().load(universeImg),\n        side: THREE.DoubleSide, \n      });\n      //mesh\n      let universeMesh = new THREE.Mesh(universeGeometry, universeMaterial);\n      universeMesh.name = \"universe\";\n      scene.add(universeMesh);\n    },\n\n    //create stars\n    createStars() {\n      const positions = [];\n      const colors = [];\n      //create geometry\n      const starsGeometry = new THREE.BufferGeometry();\n      //color and position\n      for (let i = 0; i < 10000; i++) {\n        let vertex = new THREE.Vector3();\n        vertex.x = Math.random() * 2 - 1;\n        vertex.y = Math.random() * 2 - 1;\n        vertex.z = Math.random() * 2 - 1;\n        positions.push(vertex.x, vertex.y, vertex.z);\n        let color = new THREE.Color();\n        color.setRGB(255, 255, 255);\n        colors.push(color.r, color.g, color.b);\n      }\n      starsGeometry.setAttribute(\n        \"position\",\n        new THREE.Float32BufferAttribute(positions, 3)\n      );\n      starsGeometry.setAttribute(\n        \"color\",\n        new THREE.Float32BufferAttribute(colors, 3)\n      );\n      //texture\n      let starsMaterial = new THREE.PointsMaterial({\n        map: new THREE.TextureLoader().load(starImg),\n        size: 5,\n        blending: THREE.AdditiveBlending,\n        fog: true,\n        depthTest: false,\n      });\n      //star assembly\n      let starsMesh = new THREE.Points(starsGeometry, starsMaterial);\n      starsMesh.scale.set(7000, 7000, 7000); //set the assembly scope\n      scene.add(starsMesh);\n    },\n\n    //create light\n    createLight() {\n      let ambient = new THREE.AmbientLight(new THREE.Color(0xffffff)); \n      scene.add(ambient);\n      let pointLight = new THREE.PointLight(new THREE.Color(0xffffff), 2, 1, 0);\n      pointLight.visible = true;\n      pointLight.position.set(0, 0, 0); //point light serves as the Sun\n      scene.add(pointLight);\n    },\n\n    //create sphere objects\n    createSphere(data) {\n      //special spheres\n      if (data.name == \"sun\") {\n        this.createSun(data);\n      } else if (data.name == \"earth\") {\n        this.createEarth(data);\n      } else if (data.name == \"venus\") {\n        this.createVenus(data);\n      } else if (data.name == \"saturn\") {\n        this.createSaturn(data);\n      } else {\n        //other spheres\n        let sphereGeometry = new THREE.SphereGeometry(data.size, 100, 100); \n        //textures\n        let sphereMaterial = new THREE.MeshLambertMaterial({\n          map: new THREE.TextureLoader().load(data.mapImg),\n        });\n        let sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);\n        sphereMesh.name = data.name;\n        sphereMesh.planetMsg = data;\n        sphereMesh.isPlanet = true; //identified as planet\n        sphereMesh.angle = 0; \n        //sphere position\n        sphereMesh.position.set(\n          data.position[0],\n          data.position[1],\n          data.position[2]\n        );\n        scene.add(sphereMesh);\n      }\n    },\n\n    //create the Sun\n    createSun(data) {\n      let sunGroup = new THREE.Group();\n      let sunGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n      let sunMaterial = new THREE.MeshLambertMaterial({\n        //texture\n        color: new THREE.Color(0xffffff),\n        map: new THREE.TextureLoader().load(data.mapImg),\n      });\n      let sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);\n      sunGroup.add(sunMesh);\n\n      let sunAtmosphereGeometry = new THREE.SphereGeometry(\n        data.size + 8,\n        100,\n        100\n      );\n      let sunAtmosphereMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.2,\n      });\n      let sunAtmosphereMesh = new THREE.Mesh(\n        sunAtmosphereGeometry,\n        sunAtmosphereMaterial\n      );\n      sunGroup.add(sunAtmosphereMesh);\n      sunGroup.name = data.name;\n      sunGroup.planetMsg = data;\n      sunGroup.isPlanet = true;\n      sunGroup.angle = 0;\n      //sphere position\n      sunGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(sunGroup);\n    },\n\n    //create Venus\n    createVenus(data) {\n      let venusGroup = new THREE.Group();\n      let venusGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n\n      let venusMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        map: new THREE.TextureLoader().load(data.mapImg),\n      });\n      let venusMesh = new THREE.Mesh(venusGeometry, venusMaterial);\n      venusGroup.add(venusMesh);\n      \n      let venusAtmosphereGeometry = new THREE.SphereGeometry(\n        data.size + 2,\n        100,\n        100\n      );\n      //the texture of atmosphere\n      let venusAtmosphereMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.5,\n        map: new THREE.TextureLoader().load(venusAtmosphereImg),\n      });\n      let venusAtmosphereMesh = new THREE.Mesh(\n        venusAtmosphereGeometry,\n        venusAtmosphereMaterial\n      );\n      venusGroup.add(venusAtmosphereMesh);\n      venusGroup.name = data.name;\n      venusGroup.planetMsg = data;\n      venusGroup.isPlanet = true; \n      venusGroup.angle = 0; \n      //sphere position\n      venusGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(venusGroup);\n    },\n\n    //create Earth\n    createEarth(data) {\n      let earthGroup = new THREE.Group();\n      let earthGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n     \n      let earthMaterial = new THREE.MeshPhysicalMaterial({\n        map: new THREE.TextureLoader().load(data.mapImg),\n        normalScale: new THREE.Vector2(10, 10), //normal scale\n        normalMap: new THREE.TextureLoader().load(earthNormalImg), //normal map to strengthen surface details\n      });\n      let earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);\n      earthGroup.add(earthMesh);\n      \n      let earthCloudsGeometry = new THREE.SphereGeometry(\n        data.size + 2,\n        100,\n        100\n      );\n      \n      let earthCloudsMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.4,\n        map: new THREE.TextureLoader().load(earthCloudsImg),\n      });\n      //earth clouds mesh\n      let earthCloudsMesh = new THREE.Mesh(\n        earthCloudsGeometry,\n        earthCloudsMaterial\n      );\n      earthGroup.add(earthCloudsMesh);\n\n      earthGroup.name = data.name;\n      earthGroup.planetMsg = data;\n      earthGroup.isPlanet = true;\n      earthGroup.angle = 0;\n      //position\n      earthGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(earthGroup);\n    },\n\n    //create Saturn\n    createSaturn(data) {\n      let saturnGroup = new THREE.Group(); //group of Saturn\n      let saturnGeometry = new THREE.SphereGeometry(data.size, 100, 100); //Saturn geometry\n      let saturnMaterial = new THREE.MeshLambertMaterial({\n        map: new THREE.TextureLoader().load(data.mapImg), //Saturn texture\n      });\n      let saturnMesh = new THREE.Mesh(saturnGeometry, saturnMaterial); //Saturn mesh\n      saturnGroup.add(saturnMesh); //add mesh to the group\n      //球体位置\n      saturnGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(saturnGroup);\n    },\n\n    //create orbital paths\n    createTrack(data) {\n      if (data.name == \"sun\") {\n        return;\n      }\n      //create tracks (paths)\n      let trackGeometry = new THREE.RingBufferGeometry(\n        data.position[0],\n        data.position[0] + 2,\n        1000\n      );\n      //texture\n      let trackMaterial = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        side: THREE.DoubleSide,\n      });\n      let trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);\n      trackMesh.position.set(0, 0, 0); //track position\n      trackMesh.rotation.set(0.5 * Math.PI, 0, 0); //totation the track to horizonal\n      scene.add(trackMesh);\n    },\n\n    //create mouse controls\n    createOrbitControls() {\n      orbitControls = new OrbitControls(camera, this.renderer.domElement);\n      orbitControls.enablePan = false;\n      orbitControls.enableZoom = true; //zoomming\n      orbitControls.enableDamping = true; //damping\n      orbitControls.dampingFactor = 0.05; //damping factor\n      orbitControls.minDistance = 100; //minimum distance from the camera to object\n      orbitControls.maxDistance = 2700; //maximum distance from the camera to object\n      orbitControls.autoRotate = true; //camera self rotation\n      orbitControls.autoRotateSpeed = 0;\n    },\n\n    //renderer\n    render() {\n      //request animation frame, call it when page refreshing, bond it with the frequncy of page refreshing\n      this.anId = requestAnimationFrame(this.render); //record anId to destroy the scene\n      orbitControls.update(); //update mouse controls\n      this.renderer.render(scene, camera);\n      //control revolution\n      if (this.isRevolution) {\n        this.sphereRevolution(this.planetList); //planets revoluting\n      }\n      if (this.isRotation) {\n        this.sphereRotation(this.planetList); //planets rotating\n      }\n      //listen for canvas double-click events\n      document.getElementById(\"planetDiv\") &&\n        document\n          .getElementById(\"planetDiv\")\n          .addEventListener(\"dblclick\", this.handleDblclick, false);\n      TWEEN.update(); //update animation\n    },\n\n    //double click event\n    handleDblclick(e) {\n      let dom = document.getElementById(\"planetDiv\");\n      let width = dom.clientWidth; //window width\n      let height = dom.clientHeight; //window height\n      //transfer mouse position to standard position in three.js\n      this.mouse.x = (e.offsetX / width) * 2 - 1;\n      this.mouse.y = -(e.offsetY / height) * 2 + 1;\n      //calculate raycaster through mouse position and current camera matri\n      this.raycaster.setFromCamera(this.mouse, camera);\n      //create planet mesh list\n      let palnetMeshList = [];\n      scene.children.forEach((p) => {\n        if (p.name !== \"\") {\n          palnetMeshList.push(p);\n        }\n      });\n      //get the intersection objects between raycaster and planets mesh list\n      let intersects = this.raycaster.intersectObjects(palnetMeshList);\n      //if is clicking nihility\n      if (intersects.length == 0) {\n        return;\n      }\n      //if is clicking a planet\n      if (intersects[0].object.isPlanet) {\n        this.clickPlanet = intersects[0].object;\n      } else {\n        this.clickPlanet = intersects[0].object.parent;\n      }\n      //get sphere radius\n      let planetR = \"\";\n      this.planetList.forEach((e) => {\n        if (e.name == this.clickPlanet.name) {\n          planetR = e.size;\n        }\n      });\n      //new position of camera\n      let newP = {\n        x: this.clickPlanet.position.x,\n        y: this.clickPlanet.position.y + planetR,\n        z: this.clickPlanet.position.z + 2.5 * planetR,\n      };\n      //when double clicking on planets, stop revoluting; double clicking on nihility reverses revolution status\n      if (this.clickPlanet.type !== \"Scene\") {\n        this.isRevolution = false;\n        this.isRotation = false;\n\n        //fly to the planet after click\n        this.flyTo(\n          camera.position,\n          orbitControls.target,\n          newP,\n          this.clickPlanet.position,\n          2000\n        );\n      } else {\n        this.isRevolution = !this.isRevolution;\n        this.isRotation = !this.isRotation;\n      }\n    },\n\n    //fly to a target (old camera position，old target position，new camera position，new target position，animation time，call bacl)\n    flyTo(oldP, oldT, newP, newT, time, callBack) {\n      if (TWEEN) {\n        let tween = new TWEEN.Tween({\n          x1: oldP.x, \n          y1: oldP.y, \n          z1: oldP.z, \n          x2: oldT.x, \n          y2: oldT.y, \n          z2: oldT.z,\n        });\n        tween.to(\n          {\n            x1: newP.x,\n            y1: newP.y,\n            z1: newP.z,\n            x2: newT.x,\n            y2: newT.y,\n            z2: newT.z,\n          },\n          time\n        );\n        tween.onUpdate(function (object) {\n          camera.position.set(object.x1, object.y1, object.z1);\n          orbitControls.target.x = object.x2;\n          orbitControls.target.y = object.y2;\n          orbitControls.target.z = object.z2;\n          orbitControls.update();\n        });\n        tween.onComplete(function () {\n          callBack && callBack();\n        });\n        tween.easing(TWEEN.Easing.Cubic.InOut);\n        tween.start();\n      }\n    },\n\n    //sphere rotation\n    sphereRotation(data) {\n      scene.children.forEach((e) => {\n        //filter out planet\n        if (e.isPlanet) {\n          let planetData = data.filter((d) => d.name == e.name)[0];\n          if (e.name == \"saturn\") {\n            e.rotation.x = 0.05 * 2 * Math.PI;\n          }\n          //special rotation for Uranus\n          if (e.name == \"uranus\") {\n            e.rotation.z =\n              e.rotation.z + planetData.rotation >= 2 * Math.PI\n                ? 0\n                : e.rotation.z + planetData.rotation;\n            return;\n          }\n          e.rotation.y =\n            e.rotation.y + planetData.rotation >= 2 * Math.PI\n              ? 0\n              : e.rotation.y + planetData.rotation;\n        }\n      });\n    },\n\n    //sphere revolution\n    sphereRevolution(data) {\n      scene.children.forEach((e) => {\n        //filter planets\n        if (e.isPlanet) {\n          let planetData = data.filter((d) => d.name == e.name)[0]; //get planet data\n          e.angle =\n            e.angle + planetData.revolution >= 2 * Math.PI\n              ? 0\n              : e.angle + planetData.revolution;\n          e.position.set(\n            planetData.position[0] * Math.sin(e.angle),\n            0,\n            planetData.position[0] * Math.cos(e.angle)\n          );\n        }\n      });\n    },\n  },\n};\n",{"version":3,"sources":["solarSystem.vue"],"names":[],"mappings":";AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"solarSystem.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"container\">\n    <div id=\"planetDiv\">\n      <!--绘制canvas的盒子-->\n    </div>\n    <!--描述组件-->\n    <PlanetText v-if=\"clickPlanet.planetMsg\" :msg=\"clickPlanet.planetMsg\" />\n    <!--设置组件-->\n    <SetSolarSystem @changeSet=\"changeSet\" />\n  </div>\n</template>\n<script>\nimport * as THREE from \"three\";\nimport TWEEN from \"@tweenjs/tween.js\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\"; \nimport SetSolarSystem from \"./components/SetSolarSystem\";\nimport PlanetText from \"./components/PlanetText\";\nimport planetData from \"./planetData.js\";\nimport universeImg from \"./img/universe.jpg\"; \nimport starImg from \"./img/star.jpg\";\nimport venusAtmosphereImg from \"./img/venusAtmosphere.jpg\";\nimport moonImg from \"./img/moon.jpg\";\nimport earthNormalImg from \"./img/earthNormal.jpg\";\nimport earthCloudsImg from \"./img/earthClouds.jpg\";\n\nlet scene = null; //the scene\nlet camera = null; //the camera\nlet orbitControls = null; //mouse control\nexport default {\n  props: {},\n  components: { SetSolarSystem, PlanetText },\n  data() {\n    return {\n      dom: \"\", \n      renderer: \"\",\n      anId: null,\n      planetList: planetData,\n      isRevolution: true, //revolution status\n      isRotation: true, //rotation status\n      raycaster: new THREE.Raycaster(), //to get the coordinates of mouse when on click\n      mouse: new THREE.Vector2(), \n      clickPlanet: \"\", //the on click planet\n    };\n  },\n  computed: {},\n  watch: {},\n  created() {},\n  mounted() {\n    this.init();\n  },\n  methods: {\n    //change the two settings (rotation and revolution)\n    changeSet(data) {\n      if (data.key == \"isRevolution\") {\n        this.isRevolution = data.val;\n      }\n      if (data.key == \"isRotation\") {\n        this.isRotation = data.val;\n      }\n    },\n    //destroy the scene\n    destroyScene() {\n      cancelAnimationFrame(this.anId); //stop rendering according to anId\n      this.renderer.forceContextLoss();\n      this.renderer.dispose();\n      scene.clear();\n      scene = null;\n      camera = null;\n      orbitControls = null;\n      this.dom.innerHTML = null;\n      this.renderer = null;\n    },\n\n    //initialize the scene\n    init() {\n      this.dom = document.getElementById(\"planetDiv\"); //get dom\n      let width = this.dom.clientWidth;\n      let height = this.dom.clientHeight;\n      scene = new THREE.Scene();\n      camera = new THREE.PerspectiveCamera(45, width / height, 1, 50000); //create the perspective camera\n      camera.position.set(0, 500, 2700); //set camera position\n      camera.lookAt(0, 0, 0);\n      //create renderer\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true, //antialiasing\n        alpha: true, //transparency\n      });\n      this.renderer.setClearColor(0x000000, 0.1); //set scene transparency\n      this.renderer.setSize(width, height); //set renderer size\n      this.dom.appendChild(this.renderer.domElement); //add renderer to dom to form canvas\n      this.createUniverse(); //create universe\n      this.createStars(); //create stars\n      this.createLight(); //create light\n      //traverse planet data to generate planets and their orbital paths\n      this.planetList.forEach((e) => {\n        this.createSphere(e);\n        this.createTrack(e);\n      });\n      this.createOrbitControls(); //create mouse controls\n      this.render(); //render\n    },\n\n    //create universe\n    createUniverse() {\n      let universeGeometry = new THREE.SphereGeometry(7000, 100, 100);\n      let universeMaterial = new THREE.MeshLambertMaterial({\n        //texure\n        map: new THREE.TextureLoader().load(universeImg),\n        side: THREE.DoubleSide, \n      });\n      //mesh\n      let universeMesh = new THREE.Mesh(universeGeometry, universeMaterial);\n      universeMesh.name = \"universe\";\n      scene.add(universeMesh);\n    },\n\n    //create stars\n    createStars() {\n      const positions = [];\n      const colors = [];\n      //create geometry\n      const starsGeometry = new THREE.BufferGeometry();\n      //color and position\n      for (let i = 0; i < 10000; i++) {\n        let vertex = new THREE.Vector3();\n        vertex.x = Math.random() * 2 - 1;\n        vertex.y = Math.random() * 2 - 1;\n        vertex.z = Math.random() * 2 - 1;\n        positions.push(vertex.x, vertex.y, vertex.z);\n        let color = new THREE.Color();\n        color.setRGB(255, 255, 255);\n        colors.push(color.r, color.g, color.b);\n      }\n      starsGeometry.setAttribute(\n        \"position\",\n        new THREE.Float32BufferAttribute(positions, 3)\n      );\n      starsGeometry.setAttribute(\n        \"color\",\n        new THREE.Float32BufferAttribute(colors, 3)\n      );\n      //texture\n      let starsMaterial = new THREE.PointsMaterial({\n        map: new THREE.TextureLoader().load(starImg),\n        size: 5,\n        blending: THREE.AdditiveBlending,\n        fog: true,\n        depthTest: false,\n      });\n      //star assembly\n      let starsMesh = new THREE.Points(starsGeometry, starsMaterial);\n      starsMesh.scale.set(7000, 7000, 7000); //set the assembly scope\n      scene.add(starsMesh);\n    },\n\n    //create light\n    createLight() {\n      let ambient = new THREE.AmbientLight(new THREE.Color(0xffffff)); \n      scene.add(ambient);\n      let pointLight = new THREE.PointLight(new THREE.Color(0xffffff), 2, 1, 0);\n      pointLight.visible = true;\n      pointLight.position.set(0, 0, 0); //point light serves as the Sun\n      scene.add(pointLight);\n    },\n\n    //create sphere objects\n    createSphere(data) {\n      //special spheres\n      if (data.name == \"sun\") {\n        this.createSun(data);\n      } else if (data.name == \"earth\") {\n        this.createEarth(data);\n      } else if (data.name == \"venus\") {\n        this.createVenus(data);\n      } else if (data.name == \"saturn\") {\n        this.createSaturn(data);\n      } else {\n        //other spheres\n        let sphereGeometry = new THREE.SphereGeometry(data.size, 100, 100); \n        //textures\n        let sphereMaterial = new THREE.MeshLambertMaterial({\n          map: new THREE.TextureLoader().load(data.mapImg),\n        });\n        let sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);\n        sphereMesh.name = data.name;\n        sphereMesh.planetMsg = data;\n        sphereMesh.isPlanet = true; //identified as planet\n        sphereMesh.angle = 0; \n        //sphere position\n        sphereMesh.position.set(\n          data.position[0],\n          data.position[1],\n          data.position[2]\n        );\n        scene.add(sphereMesh);\n      }\n    },\n\n    //create the Sun\n    createSun(data) {\n      let sunGroup = new THREE.Group();\n      let sunGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n      let sunMaterial = new THREE.MeshLambertMaterial({\n        //texture\n        color: new THREE.Color(0xffffff),\n        map: new THREE.TextureLoader().load(data.mapImg),\n      });\n      let sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);\n      sunGroup.add(sunMesh);\n\n      let sunAtmosphereGeometry = new THREE.SphereGeometry(\n        data.size + 8,\n        100,\n        100\n      );\n      let sunAtmosphereMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.2,\n      });\n      let sunAtmosphereMesh = new THREE.Mesh(\n        sunAtmosphereGeometry,\n        sunAtmosphereMaterial\n      );\n      sunGroup.add(sunAtmosphereMesh);\n      sunGroup.name = data.name;\n      sunGroup.planetMsg = data;\n      sunGroup.isPlanet = true;\n      sunGroup.angle = 0;\n      //sphere position\n      sunGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(sunGroup);\n    },\n\n    //create Venus\n    createVenus(data) {\n      let venusGroup = new THREE.Group();\n      let venusGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n\n      let venusMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        map: new THREE.TextureLoader().load(data.mapImg),\n      });\n      let venusMesh = new THREE.Mesh(venusGeometry, venusMaterial);\n      venusGroup.add(venusMesh);\n      \n      let venusAtmosphereGeometry = new THREE.SphereGeometry(\n        data.size + 2,\n        100,\n        100\n      );\n      //the texture of atmosphere\n      let venusAtmosphereMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.5,\n        map: new THREE.TextureLoader().load(venusAtmosphereImg),\n      });\n      let venusAtmosphereMesh = new THREE.Mesh(\n        venusAtmosphereGeometry,\n        venusAtmosphereMaterial\n      );\n      venusGroup.add(venusAtmosphereMesh);\n      venusGroup.name = data.name;\n      venusGroup.planetMsg = data;\n      venusGroup.isPlanet = true; \n      venusGroup.angle = 0; \n      //sphere position\n      venusGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(venusGroup);\n    },\n\n    //create Earth\n    createEarth(data) {\n      let earthGroup = new THREE.Group();\n      let earthGeometry = new THREE.SphereGeometry(data.size, 100, 100);\n     \n      let earthMaterial = new THREE.MeshPhysicalMaterial({\n        map: new THREE.TextureLoader().load(data.mapImg),\n        normalScale: new THREE.Vector2(10, 10), //normal scale\n        normalMap: new THREE.TextureLoader().load(earthNormalImg), //normal map to strengthen surface details\n      });\n      let earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);\n      earthGroup.add(earthMesh);\n      \n      let earthCloudsGeometry = new THREE.SphereGeometry(\n        data.size + 2,\n        100,\n        100\n      );\n      \n      let earthCloudsMaterial = new THREE.MeshLambertMaterial({\n        color: new THREE.Color(0xffffff),\n        transparent: true,\n        opacity: 0.4,\n        map: new THREE.TextureLoader().load(earthCloudsImg),\n      });\n      //earth clouds mesh\n      let earthCloudsMesh = new THREE.Mesh(\n        earthCloudsGeometry,\n        earthCloudsMaterial\n      );\n      earthGroup.add(earthCloudsMesh);\n\n      earthGroup.name = data.name;\n      earthGroup.planetMsg = data;\n      earthGroup.isPlanet = true;\n      earthGroup.angle = 0;\n      //position\n      earthGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(earthGroup);\n    },\n\n    //create Saturn\n    createSaturn(data) {\n      let saturnGroup = new THREE.Group(); //group of Saturn\n      let saturnGeometry = new THREE.SphereGeometry(data.size, 100, 100); //Saturn geometry\n      let saturnMaterial = new THREE.MeshLambertMaterial({\n        map: new THREE.TextureLoader().load(data.mapImg), //Saturn texture\n      });\n      let saturnMesh = new THREE.Mesh(saturnGeometry, saturnMaterial); //Saturn mesh\n      saturnGroup.add(saturnMesh); //add mesh to the group\n      //球体位置\n      saturnGroup.position.set(\n        data.position[0],\n        data.position[1],\n        data.position[2]\n      );\n      scene.add(saturnGroup);\n    },\n\n    //create orbital paths\n    createTrack(data) {\n      if (data.name == \"sun\") {\n        return;\n      }\n      //create tracks (paths)\n      let trackGeometry = new THREE.RingBufferGeometry(\n        data.position[0],\n        data.position[0] + 2,\n        1000\n      );\n      //texture\n      let trackMaterial = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        side: THREE.DoubleSide,\n      });\n      let trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);\n      trackMesh.position.set(0, 0, 0); //track position\n      trackMesh.rotation.set(0.5 * Math.PI, 0, 0); //totation the track to horizonal\n      scene.add(trackMesh);\n    },\n\n    //create mouse controls\n    createOrbitControls() {\n      orbitControls = new OrbitControls(camera, this.renderer.domElement);\n      orbitControls.enablePan = false;\n      orbitControls.enableZoom = true; //zoomming\n      orbitControls.enableDamping = true; //damping\n      orbitControls.dampingFactor = 0.05; //damping factor\n      orbitControls.minDistance = 100; //minimum distance from the camera to object\n      orbitControls.maxDistance = 2700; //maximum distance from the camera to object\n      orbitControls.autoRotate = true; //camera self rotation\n      orbitControls.autoRotateSpeed = 0;\n    },\n\n    //renderer\n    render() {\n      //request animation frame, call it when page refreshing, bond it with the frequncy of page refreshing\n      this.anId = requestAnimationFrame(this.render); //record anId to destroy the scene\n      orbitControls.update(); //update mouse controls\n      this.renderer.render(scene, camera);\n      //control revolution\n      if (this.isRevolution) {\n        this.sphereRevolution(this.planetList); //planets revoluting\n      }\n      if (this.isRotation) {\n        this.sphereRotation(this.planetList); //planets rotating\n      }\n      //listen for canvas double-click events\n      document.getElementById(\"planetDiv\") &&\n        document\n          .getElementById(\"planetDiv\")\n          .addEventListener(\"dblclick\", this.handleDblclick, false);\n      TWEEN.update(); //update animation\n    },\n\n    //double click event\n    handleDblclick(e) {\n      let dom = document.getElementById(\"planetDiv\");\n      let width = dom.clientWidth; //window width\n      let height = dom.clientHeight; //window height\n      //transfer mouse position to standard position in three.js\n      this.mouse.x = (e.offsetX / width) * 2 - 1;\n      this.mouse.y = -(e.offsetY / height) * 2 + 1;\n      //calculate raycaster through mouse position and current camera matri\n      this.raycaster.setFromCamera(this.mouse, camera);\n      //create planet mesh list\n      let palnetMeshList = [];\n      scene.children.forEach((p) => {\n        if (p.name !== \"\") {\n          palnetMeshList.push(p);\n        }\n      });\n      //get the intersection objects between raycaster and planets mesh list\n      let intersects = this.raycaster.intersectObjects(palnetMeshList);\n      //if is clicking nihility\n      if (intersects.length == 0) {\n        return;\n      }\n      //if is clicking a planet\n      if (intersects[0].object.isPlanet) {\n        this.clickPlanet = intersects[0].object;\n      } else {\n        this.clickPlanet = intersects[0].object.parent;\n      }\n      //get sphere radius\n      let planetR = \"\";\n      this.planetList.forEach((e) => {\n        if (e.name == this.clickPlanet.name) {\n          planetR = e.size;\n        }\n      });\n      //new position of camera\n      let newP = {\n        x: this.clickPlanet.position.x,\n        y: this.clickPlanet.position.y + planetR,\n        z: this.clickPlanet.position.z + 2.5 * planetR,\n      };\n      //when double clicking on planets, stop revoluting; double clicking on nihility reverses revolution status\n      if (this.clickPlanet.type !== \"Scene\") {\n        this.isRevolution = false;\n        this.isRotation = false;\n\n        //fly to the planet after click\n        this.flyTo(\n          camera.position,\n          orbitControls.target,\n          newP,\n          this.clickPlanet.position,\n          2000\n        );\n      } else {\n        this.isRevolution = !this.isRevolution;\n        this.isRotation = !this.isRotation;\n      }\n    },\n\n    //fly to a target (old camera position，old target position，new camera position，new target position，animation time，call bacl)\n    flyTo(oldP, oldT, newP, newT, time, callBack) {\n      if (TWEEN) {\n        let tween = new TWEEN.Tween({\n          x1: oldP.x, \n          y1: oldP.y, \n          z1: oldP.z, \n          x2: oldT.x, \n          y2: oldT.y, \n          z2: oldT.z,\n        });\n        tween.to(\n          {\n            x1: newP.x,\n            y1: newP.y,\n            z1: newP.z,\n            x2: newT.x,\n            y2: newT.y,\n            z2: newT.z,\n          },\n          time\n        );\n        tween.onUpdate(function (object) {\n          camera.position.set(object.x1, object.y1, object.z1);\n          orbitControls.target.x = object.x2;\n          orbitControls.target.y = object.y2;\n          orbitControls.target.z = object.z2;\n          orbitControls.update();\n        });\n        tween.onComplete(function () {\n          callBack && callBack();\n        });\n        tween.easing(TWEEN.Easing.Cubic.InOut);\n        tween.start();\n      }\n    },\n\n    //sphere rotation\n    sphereRotation(data) {\n      scene.children.forEach((e) => {\n        //filter out planet\n        if (e.isPlanet) {\n          let planetData = data.filter((d) => d.name == e.name)[0];\n          if (e.name == \"saturn\") {\n            e.rotation.x = 0.05 * 2 * Math.PI;\n          }\n          //special rotation for Uranus\n          if (e.name == \"uranus\") {\n            e.rotation.z =\n              e.rotation.z + planetData.rotation >= 2 * Math.PI\n                ? 0\n                : e.rotation.z + planetData.rotation;\n            return;\n          }\n          e.rotation.y =\n            e.rotation.y + planetData.rotation >= 2 * Math.PI\n              ? 0\n              : e.rotation.y + planetData.rotation;\n        }\n      });\n    },\n\n    //sphere revolution\n    sphereRevolution(data) {\n      scene.children.forEach((e) => {\n        //filter planets\n        if (e.isPlanet) {\n          let planetData = data.filter((d) => d.name == e.name)[0]; //get planet data\n          e.angle =\n            e.angle + planetData.revolution >= 2 * Math.PI\n              ? 0\n              : e.angle + planetData.revolution;\n          e.position.set(\n            planetData.position[0] * Math.sin(e.angle),\n            0,\n            planetData.position[0] * Math.cos(e.angle)\n          );\n        }\n      });\n    },\n  },\n};\n</script>\n<style scoped lang='scss'>\n.container {\n  height: 100%;\n  width: 100%;\n  position: relative;\n  #planetDiv {\n    height: 100%;\n    width: 100%;\n  }\n}\n</style>"]}]}